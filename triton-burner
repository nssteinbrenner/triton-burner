#!/usr/bin/env python

import time
import requests
import splinter
import os

from bs4 import BeautifulSoup


class Triton:

    def __init__(self, sn, dev):
        """Initialize class variables.

        sn: String representation of serial number of Triton
        dev: String representation of device ID of Triton.
        """

        self.serial = sn
        self.devid = dev
        self.battery = None
        self.snr = None
        self.mirrortemp = None
        self.ambtemp = None
        self.windvert = None
        self.lat = None
        self.lon = None
        self.weather = None
        self.burningstatus = False
        self.lastburn = None
        self.burn = False
        self.erroroccur = False
        self.country = None
        self.burnurl = 'redacted'

    def __str__(self):
        """Returns neatly formatted text representation of Triton.
        """

        return f"""\n\tT{self.serial}\n
            \tBattery: {self.battery}\n
            \tSNR: {self.snr}\n
            \tMirrorTemp: {self.mirrortemp}\n
            \tAmbientTemp: {self.ambtemp}\n
            \tWindVert: {self.windvert}\n
            \tLat: {self.lat}\n
            \tLon: {self.lon}\n
            \tCountry: {self.country}\n
            \tWeather: {self.weather}\n
            \tBurning: {self.burningstatus}\n
            \tLast Burn: {self.lastburn}\n
            \tBurn URL: {self.burnurl}\n"""

    def setBattery(self, battery):
        """Defines the Triton's battery voltage variable.

        battery: Battery voltage. Must be able to convert to float.
        """

        if '(None)' not in battery:
            self.battery = float(battery)

    def setSnr(self, snr):
        """Defines the Triton's signal to noise ratio.

        snr: Signal to noise ratio. Must be able to convert to float.
        """

        if '(None)' not in snr:
            self.snr = float(snr)

    def setMirrortemp(self, mirrortemp):
        """Defines the Triton's mirror temperature.

        mirrortemp: Mirror temperature. Must be able to convert to float.
        """

        if '(None)' not in mirrortemp:
            self.mirrortemp = float(mirrortemp)

    def setAmbtemp(self, ambtemp):
        """Defines the Triton's ambient temperature.

        ambtempt: Ambient temperature. Must be able to convert to float.
        """

        if '(None)' not in ambtemp:
            self.ambtemp = float(ambtemp)

    def setWindvert(self, windvert):
        """Defines the Triton's vertical wind speed.

        windvert: Vertical wind speed. Must be able to convert to float.
        """

        if '(None)' not in windvert:
            self.windvert = float(windvert)

    def setBurningStatus(self, burning):
        """Checks to see if the Triton is currently in 'burning' state.

        burning: String representation of current Triton state.

        Always one of the following:

        'Job Running'
        'Job Complete'
        'Pending'
        'Error'
        """

        if 'Running' in burning:
            self.burningstatus = True
        if 'Pending' in burning:
            self.burningstatus = True
        if 'Error' in burning:
            self.burningstatus = 'Error'

    def setLastBurn(self, lastburn):
        """Defines the time the last burn was completed.

        lastburn: Time in 24hr format.
        """

        self.lastburn = lastburn

    def setLat(self, lat):
        """Defines latitude of the Triton's location.

        lat: Latitude, must be string.
        """

        if 'None' not in lat:
            self.lat = lat

    def setLon(self, lon):
        """Defines longitude of the Triton's location.

        lon: Longitude, must be string.
        """

        if 'None' not in lon:
            self.lon = lon

    def setDev(self, devid):
        """Defines the device ID of the Triton.

        devid: Device ID, can be int or str. Must be able to convert to str.
        """

        self.devid = str(devid)

    def setWeather(self):
        """Defines the Triton's weather variable.

        Checks three different weather sources, and appends
        them to a list. At the end, it joins them all into
        a space separated string.

        All errors are timestamped and written to a file in the
        directory of the script called 'weatherError'.
        """

        allWeather = []

        try:
            with splinter.Browser('firefox', headless=True) as browser:
                url = (f'https://forecast.weather.gov/MapClick.php?'
                       f'lat={self.lat}&lon={self.lon}')
                browser.visit(url)
                time.sleep(5)
                webpage = browser.html
                soup = BeautifulSoup(webpage, 'html.parser')
                for p in soup.find_all('p', 'myforecast-current'):
                    if p.string is not None:
                        if len(p.string) > 1:
                            allWeather.append(str(p.string).lower())

        except Exception as e:
            today = time.strftime("%Y-%m-%d", time.gmtime())
            now = time.strftime("%H:%M", time.gmtime())
            with open('weatherError', 'a+') as f:
                f.write(f'{today} {now} - Error grabbing weather '
                        f'from weather.gov for T{self.serial}\n\t{e}\n')

        try:
            with open('config', 'r') as config:
                lines = config.readlines()
                for line in lines:
                    if 'api:' in line:
                        target = line.strip().split(' ')
                        api = target[1]

            url = (f'https://api.darksky.net/forecast/{api}/'
                   f'{self.lat},{self.lon}')

            weather = requests.get(url)
            weather.raise_for_status()

            w = weather.json()
            allWeather.append(w['currently']['icon'])

        except Exception as e:
            today = time.strftime("%Y-%m-%d", time.gmtime())
            now = time.strftime("%H:%M", time.gmtime())
            with open('weatherError', 'a+') as f:
                f.write(f'{today} {now} - Error grabbing weather '
                        f'from darksky for T{self.serial}\n\t{e}\n')

        try:
            with splinter.Browser('firefox', headless=True) as browser:
                url = (f'https://www.wunderground.com/weather/'
                       f'{self.lat}%2C{self.lon}')
                browser.visit(url)
                time.sleep(5)
                wunderground = browser.html
                soup = BeautifulSoup(wunderground, 'html.parser')
                for p in soup.find_all('p'):
                    if p.string is not None:
                        if 'snow' in str(p.string.lower()):
                            allWeather.append(str(p.string).lower())

        except Exception as e:
            today = time.strftime("%Y-%m-%d", time.gmtime())
            now = time.strftime("%H:%M", time.gmtime())
            with open('weatherError', 'a+') as f:
                f.write(f'{today} {now} - Error grabbing weather'
                        f'from wunderground for T{self.serial}\n\t{e}\n')

        self.weather = ' '.join(allWeather)

    def setBurn(self):
        """Checks to see if the Triton should be burned or not.
        """

        if self.windvert is not None and self.battery is not None \
                and self.ambtemp is not None:
            if self.windvert <= -0.5 and self.windvert >= -2.5:
                if self.battery >= 12:
                    if self.ambtemp <= 4:
                        self.burn = True

    def activateBurn(self):
        """Runs the burn command on the Triton.

        Checks to see if Triton has a potential error.
        It does so by checking the duration of the last burn.

        Burn command is issued through web browser automation
        using Splinter. Checks to see if there are special scripts
        for burning by running through values above the normal range.
        If so, it runs the special script. Otherwise the default value is '2'.
        """

        if f'T{self.serial}' in errored:
            print(f"Skipping. T{self.serial} is in error list.")
        elif self.errorChecker() is not None and self.errorChecker() <= 75:
            print(f"Skipping. T{self.serial} has been burned "
                  f"{self.errorChecker()} minutes ago. Check for errors.")
            self.errorWriter()
        else:
            self.logBurn()
            try:
                with splinter.Browser('firefox', headless=True) as browser:
                    browser.visit(self.burnurl)
                    time.sleep(7)
                    (browser.find_by_id('login').first
                            .find_by_name('username').fill(username))
                    (browser.find_by_id('login').first
                            .find_by_name('password').fill(password))
                    (browser.find_by_id('login')
                            .first.find_by_value('Login').click())
                    time.sleep(7)
                    value = '2'
                    for i in range(5, 20):
                        if browser.is_element_present_by_value(str(i)) is True:
                            value = str(i)
                            break
                    browser.execute_script(f'document.getElementById'
                                           f'("id_selection").value = '
                                           f'"{value}"')
                    browser.find_by_value('Burn Heaters').first.click()

            except Exception as e:
                today = time.strftime("%Y-%m-%d", time.gmtime())
                now = time.strftime("%H:%M", time.gmtime())
                with open('burnerror', 'a+') as f:
                    f.write(f'Failed to burn T{self.serial} at '
                            f'{today} {now} GMT\n{str(self)}\n\t{e}\n')

    def logBurn(self):
        """Writes to a log file when a burn command is issued.

        Log file is in subdirectory of the script's directory.
        File is always titled todays date with the following format:

        {year}-{month}-{day}

        example: /home/user/triton-burner/log/2018-10-26
        """

        today = time.strftime("%Y-%m-%d", time.gmtime())
        now = time.strftime("%H:%M", time.gmtime())
        with open(f'log/{today}', 'a+') as log:
            log.write(f'Issued burn to T{self.serial} at {now}\n')

    def setCountry(self):
        """Checks to see what country the Triton is in based off lat/lon

        Defines country variable of the Triton with the two letter
        abbreviation of the country.

        example: 'US'

        Queries from Google's geocode api.
        """

        if self.lat is None or self.lon is None:
            return None

        with open('config', 'r') as f:
            lines = f.readlines()
            for line in lines:
                if 'google:' in line:
                    line = line.strip().split(' ')
                    gapi = line[1]

        try:
            geourl = (f'https://maps.googleapis.com/maps/api/geocode/json?'
                      f'latlng={self.lat},{self.lon}&key={gapi}')

            location = requests.get(geourl)
            location.raise_for_status()

            loc = location.json()

            country = loc['results'][-1]['address_components'][0]['short_name']

            self.country = country

        except Exception as e:
            today = time.strftime("%Y-%m-%d", time.gmtime())
            now = time.strftime("%H:%M", time.gmtime())
            with open('countryError', 'a+') as f:
                f.write(f'{today} {now} - Error grabbing country '
                        f'from Google API for T{self.serial}\n\t{e}\n')

    def errorChecker(self):
        """Returns the difference between now and the last completed burn.

        Calculates difference between now and the last completed burn,
        this is to check for errors. If a burn ran too short (e.g 15 min)
        there may be a problem with that Triton.

        However there are sometimes communications issues, where the only
        resolution is to repeatedly issue the burn command. In this case,
        it returns 'None', so that those Triton's are not caught by the
        error checking, and a new burn command is issued.
        """

        if 'Error' in str(self.getBurningStatus()):
            return None
        if f'T{self.serial}' in burned:
            now = time.strftime("%H:%M", time.gmtime())
            then = burned[f'T{self.serial}']
            difference = timediff(now, then)
            return difference

    def errorWriter(self):
        """Writes errors to a log file.

        Error file is in a subdirectory of the script's directory.
        File is always titled todays date in the following format:

        {year}-{month}-{day}

        example: /home/user/triton-burner/error/2018-10-26
        """

        today = time.strftime("%Y-%m-%d", time.gmtime())
        now = time.strftime("%H:%M", time.gmtime())
        with open(f'error/{today}', 'a') as error:
            error.write(f'T{self.serial} - {now} - Possible error\n')

    def getBurn(self):
        return self.burn

    def getBurningStatus(self):
        return self.burningstatus

    def getSerial(self):
        return self.serial

    def getWeather(self):
        return str(self.weather)

    def getDev(self):
        return self.devid

    def getCountry(self):
        return str(self.country)


today = time.strftime("%Y-%m-%d", time.gmtime())
burned = {}
errored = []


def timediff(now, then):
    """Calculates the difference in minutes between two points in time.

    now: String represenation of time on a 24hr clock. e.g 13:56
    then: String representation of time on a 24hr clock.

    Converts the time to minutes and gets the difference between the two
    points.
    """

    now = now.split(':')
    then = then.split(':')
    nowmin = ((int(now[0]) * 60) + int(now[1]))
    thenmin = ((int(then[0]) * 60) + int(then[1]))
    return nowmin - thenmin


# Checks the log file creates a list of Tritons that have been burned today.
if os.path.exists(f'log/{today}'):
    with open(f'log/{today}', 'r') as log:
        lines = log.readlines()
        for line in lines:
            if len(line) > 1:
                line = line.strip().split(' ')
                burned[line[3]] = line[5]

# Checks the error file to create a list of Triton's that have errored today.
if os.path.exists(f'error/{today}'):
    with open(f'error/{today}') as error:
        lines = error.readlines()
        for line in lines:
            if len(line) > 1:
                line = line.strip().split(' ')
                errored.append(line[0])

# Grabs credentials from a config file in the local directory.
with open('config', 'r') as config:
    lines = config.readlines()
    for line in lines:
        if 'pw:' in line:
            target = line.strip().split(' ')
            password = target[1]
        if 'user:' in line:
            target = line.strip().split(' ')
            username = target[1]

# Automates a web browser to pull the HTML of the Triton list
with splinter.Browser('firefox', headless=True) as browser:
    url = 'redacted'
    browser.visit(url)
    time.sleep(3)
    (browser.find_by_id('login-form').first
            .find_by_name('username').fill(username))
    (browser.find_by_id('login-form').first
            .find_by_name('password').fill(password))
    (browser.find_by_id('login-form').first
            .find_by_value('Log in').click())
    time.sleep(10)
    tritonwebpage = browser.html

# Opens the HTML of the Triton list in BeautifulSoup for parsing.
soup = BeautifulSoup(tritonwebpage, 'html.parser')

index = 0
tritonclasslist = []


# Parses the HTML of the Triton list to pull required values.
# Constructs a Triton Triton with those values.
# Then puts all Tritons in a list in order of when they were created.
for a in soup.find_all('a'):
    if 'changelist_filters' in a['href'] and 'Add heater' not in str(a.string):
        spliturl = str(a['href']).split('/')
        deviceid = spliturl[4]
        tritonsn = str(a.string)
        # Dynamically creates Tritons bsed off of their serial number.
        exec(f'T{tritonsn} = Triton({tritonsn}, deviceid)')
        exec(f'tritonclasslist.append(T{tritonsn})')
    if 'forecast.weather.gov' in a['href'] or 'observations' in a['href']:
        coords = str(a.string).strip().split(' ')
        coords[0] = coords[0][:-1]
        exec(f'T{tritonsn}.setLat(coords[0])')
        exec(f'T{tritonsn}.setLon(coords[1])')
    if 'redacted' in a['href']:
        burning = str(a.string).strip().split(' ')
        burnstatus = ' '.join(burning[0:2])
        lastburntime = ' '.join(burning[2:])
        exec(f'T{tritonsn}.setBurningStatus(burnstatus)')
        exec(f'T{tritonsn}.setLastBurn(lastburntime)')

for td in soup.find_all('td'):
    if 'field-battery' in td['class']:
        battery = str(td.string)
        tritonclasslist[index].setBattery(battery)
    if 'field-wind_vert' in td['class']:
        windvert = str(td.string)
        tritonclasslist[index].setWindvert(windvert)
    if 'field-snr' in td['class']:
        snr = str(td.string)
        tritonclasslist[index].setSnr(snr)
    if 'field-amb_temp' in td['class']:
        ambtemp = str(td.string)
        tritonclasslist[index].setAmbtemp(ambtemp)
    if 'field-mirror_temp' in td['class']:
        mirrortemp = str(td.string)
        tritonclasslist[index].setMirrortemp(mirrortemp)
        index += 1

# Checks to if a Triton should be burned, then sends the burn command if so.
for i in tritonclasslist:
    i.setBurn()
    if i.getBurn() is True and i.getBurningStatus() is not True:
        i.setWeather()
        i.setCountry()
        if 'snow' in i.getWeather() or 'sleet' in i.getWeather():
            if 'US' in i.getCountry() or 'CA' in i.getCountry():
                i.activateBurn()
